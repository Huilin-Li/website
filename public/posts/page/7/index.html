<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="我的博客" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/posts/" />

<title>我的博客 | Huilin Li</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/logo.png" >
<link rel="canonical" href="http://localhost:1313/posts/">
<link rel="stylesheet" href="/book.min.f3de075a26891530cb4ae6aeb9b647bcc541281bbd3ec57e8bf60cb157bc209f.css" integrity="sha256-894HWiaJFTDLSuauubZHvMVBKBu9PsV&#43;i/YMsVe8IJ8=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.63b6564d7b3b31dd72b69135cc6c6b73c5ad27a2c8e9373f7ae6f091b7281354.js" integrity="sha256-Y7ZWTXs7Md1ytpE1zGxrc8WtJ6LI6Tc/eubwkbcoE1Q=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/posts/index.xml" title="Huilin Li" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" /><span>Huilin Li</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/me/" class="">Keep Things Simple</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Blog</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/bioworld/" class="">Biology World</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/bioworld/binderdesign/" class="">TP Binder Design</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/bioworld/proteinstruture/" class="">4 levels of protein structure</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/hugo/" class="">Hugo</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/hugo/hugobookgithubaction/" class="">HugoBook&#43;GithubAction</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/hugo/hugo/" class="">Hugo Commands</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/shell/" class="">Bash Scripts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <span>literature</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Plotly</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/plotly/examples/" class="">Visualization via plotly</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/travel/" class="">World</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href="/posts/"  >
        我的博客
      </a>
  </li>
  
  <li>
    <a href="https://github.com/Huilin-Li"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://www.goodreads.com/review/list/177314441"  target="_blank" rel="noopener">
        goodreads
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>我的博客</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  <nav>
  <ul>
  
    
    <li class="book-section-flat">
      <strong>Categories</strong>
      <ul>
      
      </ul>
    </li>
    
  
    
    <li class="book-section-flat">
      <strong>Tags</strong>
      <ul>
      
        <li class="flex justify-between">
          <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
          <span>76</span>
        </li>
      
      </ul>
    </li>
    
  
  </ul>
</nav>


  </aside>
  
 
      </header>

      
      
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
    </h2>
    
  <h5>August 2, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>动态规划的定义#最优子结构（数学优化方法） 动态规划是数学优化的方法指，动态规划要解决的都是问题的最优解。而一个问题的最优解是由它的各个子问题的最优解决定的。 重叠子问题（编程方法） 动态规划是编程的方法指，可以借助编程的技巧去保证每个重叠的子问题只会被求解一次。 因此，判断一个问题能不能称得上是动态规划的问题，需要看它是满足这两个重要的属性：最优子结构（Optimal Substructure）和重叠子问题（Overlapping Sub-problems）。
动态规划方法#递归（Recursion）#递归的解法需要耗费非常多的重复计算，很多计算都是重叠的，可以使用记忆化的方法避免重叠计算问题。
记忆化（Memoization）#记忆化，就是将已经计算出来的结果保存起来，那么下次遇到相同的输入时，直接返回保存好的结果，能够有效节省了大量的计算时间。
自底向上（Bottom-Up）#自底向上指，通过状态转移方程，从最小的问题规模入手，不断地增加问题规模，直到所要求的问题规模为止。依然使用记忆化避免重复的计算，不需要递归。
斐波那契数列#写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. Java代码
// 递归的实现 public int fib(int n) { if(n &lt;= 1){ return n; }else{ return fib(n-1)+fib(n-2); } } // 记忆化的实现 public int fib(int n) { // 用于记忆上一次的结果 int[] fn = new int[n+1]; fn[0] = 0; fn[1] = 1; for (int i = 2; i &lt;= n; i++) { fn[i] = fn[i-1] + fn[i-2]; } return fn[n]; } // 自底向上的实现 public int fib(int n) { if(n &lt;= 1) { return n; } int f0 = 0, f1 = 1, res = 0; for(int i = 2; i &lt;= n; i++) { res = f0 + f1; f0= f1; f1= res; } return res; } 动态规划面试题分类#线性规划#线性，就是说各个子问题的规模以线性的方式分布，并且子问题的最佳状态或结果可以存储在一维线性的数据结构里，例如一维数组，哈希表等。
        <a href="/posts/history/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/%E5%9B%BE%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/">图深度、广度优先遍历</a>
    </h2>
    
  <h5>August 2, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>图的种类#1、无向图（Undirected Graph）：每个顶点和其他顶点通过相连线连接。 2、有向图(Drirected Graph)：有向图中的相连线是有方向的。 3、权重图(Weighted Graph)：在权重图中，每条相连线各自有各自的权重。
有向图的实现#1、矩阵
使用矩阵来表示图之间的连向关系，用一个一维数组来保存顶点，再二维数组来保存顶点之间的关联。如：
1-&gt;2有关联，就在edge[1][2]=1来表示。
2、链表 用链表来表示两个顶点之间的关系，用一维数组来保存各个顶点，再以顶点为头节点，关联边用链表串起来。如：
0-&gt;1有关联，就用一条链表保存起来。
DFS与BFS过程#深度优先算法主要与栈有关（先进后出），广度优先算法与堆有关（先进先出）。
深度优先算法#过程：
1、先将0放在栈中 栈中数据：0 打印数据：
2、0出栈并打印，把0相关联的放入栈中，即把1、2放入栈中 栈中数据：1、2 打印数据：0
3、1出栈并打印，把1相关联的放入栈中，即把3、4放入栈中 栈中数据：3、4、2 打印数据：0、1
4、3出栈并打印，3没有相关联的了，就没有数据入栈 栈中数据：4、2 打印数据：0、1、3
5、4出栈并打印，4没有相关联的了，就没有数据入栈 栈中数据：2 打印数据：0、1、3、4
6、2出栈并打印，把2相关联的放入栈中，即把5、6放入栈中 栈中数据：5、6 打印数据：0、1、3、4、2
7、5出栈并打印，5没有相关联的了，就没有数据入栈 栈中数据：6 打印数据：0、1、3、4、2、5
8、6出栈并打印，6没有相关联的了，就没有数据入栈 栈中数据： 打印数据：0、1、3、4、2、5、6
9，栈中没有数据，结束。
广度优先算法#过程：
1、0放入堆中 堆中数据：0 打印数据：
2、0出堆并打印，把与0相关联的1、2放入堆中 堆中数据：2、1 打印数据：0
3、1出堆并打印，把与1相关联的3、4放入堆中 堆中数据：4、3、2 打印数据：0、1
4、2出堆并打印，把与2相关联的5、6放入堆中 堆中数据：6、5、4、3 打印数据：0、1、2
5、3出堆并打印，因为没有相关联的，所以没有数据放入堆中 堆中数据：6、5、4 打印数据：0、1、2、3
6、3出堆并打印，因为没有相关联的，所以没有数据放入堆中 堆中数据：6、5 打印数据：0、1、2、3、4
7、3出堆并打印，因为没有相关联的，所以没有数据放入堆中 堆中数据：6 打印数据：0、1、2、3、4、5
        <a href="/posts/history/%E5%9B%BE%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/redis/">Redis</a>
    </h2>
    
  <h5>July 29, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>Redis的线程模型#客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。
假设此时客户端发送了一个 set key value 请求，此时 redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与令回复处理器关联。
如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。
redis单线程模型效率高#对redis里的数据操作的时候是纯内存操作。 文件事件处理器的核心机制是非阻塞的IO多路复用程序。 单线程避免了多线程频繁上下文切换带来的损耗。 redis的过期策略和内存淘汰机制#定期删除 定期删除是指redis默认会每隔100ms会随机抽取一些设置了过期时间的key检查是否过期了，如果过期了就删除。
        <a href="/posts/history/redis/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/java8%E6%96%B0%E7%89%B9%E6%80%A7/">Java8新特性</a>
    </h2>
    
  <h5>July 29, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>Lambda表达式#Lambda 表达式的引入避免了匿名方法的麻烦使用，并且给予Java简单但是强大的函数化的编程能力。
使用
// 在1.8之前使用 new Thread(new Runnable() { @Override public void run() { System.out.println(&#34;Before Java8!&#34;); } }).start(); // 在1.8之后使用 new Thread(() -&gt; System.out.println(&#34;In Java8!&#34;) ).start(); 语法
基本语法: (parameters) -&gt; expression 或 (parameters) -&gt;{ statements; }
// 1. 不需要参数,返回值为 5 () -&gt; {return 5;} () -&gt; 5 // 只有一行，可以省略{}和return // 2. 接收一个参数(数字类型),返回其2倍的值 (x) -&gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -&gt; x – y // 4.
        <a href="/posts/history/java8%E6%96%B0%E7%89%B9%E6%80%A7/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/jvm%E5%8F%82%E6%95%B0/">Jvm参数</a>
    </h2>
    
  <h5>July 28, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>调优的目的
减少Minor GC、Major GC、Full GC（在GC的过程中，程序会STW[stop the world]，程序会出现卡顿，减少GC会提升程序的运行流畅和效率）。 其中Full GC时间最长，首先要减少Full GC。 常用的调优工具
Java内置的VisualVM
JVM参数
参数 说明 -Xms100M 初始化堆空间大小，-XX:InitialHeapSize=100M -Xmx100M 最大堆空间大小，-XX:MaxHeapSize=100M -Xmn20M 年轻代空间大小，-XX:NewSize=20M -Xss512k 设置线程空间大小 -XX:PermGen 设置永久代内存初始化大小,jdk1.8开始废弃永久代 -XX:MaxPermGen 设置永久代最大值 -XX:SurvivorRatio 设置Eden区和Survivor区的空间比例:Eden/S0=Eden/S1 默认为8 -XX:NewRatio 设置年老代和年轻代的大小比例,默认值是2 -XX:PermSize=256m 永久区空间大小 -XX:MaxPermSize=256m 最大永久区空间大小 -XX:+UseStringCache 启用缓存常用字符串,默认开启 -XX:+UseConcMarkSweepGC 年老代使用cms收集器 -XX:UseParNewGC 新生代使用并行收集器 -XX:ParallelGCThreads=4 并行线程数量 -XX:CMSClassUnloadingEnabled 允许对类元素进行清理 -XX:+DisableExplicitGC 禁止显示GC -XX:UseCMSInitiatingOccupancyOnly 表示只有达到阀值的时候用进行cms回收 -XX:CMSInitiatingOccupancyFraction=70 设置cms在老年代回收的阀值为70% -verbose:gc 输出虚拟机GC详情 -XX:+PrintGCDetails 打印GC详情日志 -XX:+PrintGCDateStamps 打印GC耗时 -XX:+PrintTenuringDistribution 打印Tenuring年龄信息 -XX:+HeapDumpOnOutOfMemoryError 当抛出oom错误时进行HeapDump -XX:HeapDumpPath=/home/admin/logs 指定HeapDump文件的输出路径 -XX:+UseSerialGC 串行,Young区和Old区都使用串行,使用复制算法回收,逻辑简单高效,无线程切换开销 -XX:+UseParallelGC 并行, Young区:使用Parallel Scavenge回收算法,会产生多个线程并行回收.通过 -XX:ParallelGCThreads=n 参数指定线程数,默认是cpu核数;Old区:单线程 -XX:+UseParallelOldGC 并行,和UseParallelGC一样,Young区和Old区的垃圾回收都用多线程收集 -XX:+UseConcMarkSweepGC 并发、短暂停顿的并发收集。young区：可以使用普通的Parallel垃圾收集算法由参数 -XX:+UseParNewGC来控制;old区:只能使用Concurrent Mark Sweep -XX:+UseG1GC 并行的、并发的和增量式压缩短暂停顿的垃圾收集器。不区分Young区和Old区空间。它把堆空间划分为多个大小相等的区域。当进行垃圾收集时，它会优先收集存活对象比较少的区域，因此叫&quot;Garbage First&quot; 
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/javagc/">Java Gc</a>
    </h2>
    
  <h5>July 27, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>堆的回收区域
新生代（Young Generation）NewSize和MaxNewSize分别可以控制年轻代的初始大小和最大的大小。 老年代（Old Generation）。 永久代（Permanent Generation）【1.8以后采用元空间，不在虚拟机里，而是使用本地内存】。 三大垃圾收集算法
标记/清除算法 复制算法 标记/整理算法 JVM GC算法
JVM采用“分代收集算法”对不同区域采用不同的回收算法。 新生代采用复制算法。 老年代采用标记/清除算法或标记/整理算法。 GC过程
1-2、当new新对象时，Eden空间满了，使用复制算法把存活的对象复制到空的S0(S1)上。 3-4、判断S1中存活对象的年龄值，当年龄值+1达到15时（默认15，可修改），对象将进入老年代，当没有满足时，就复制进去S0中。
大对象直接进入老年代。 当对象总数大于Survivor（S0/S1）的一半时，也会直接进入老年代。 判断对象是否存活算法 1.引用计数算法 早期判断对象是否存活大多都是以这种算法，这种算法判断很简单，简单来说就是给对象添加一个引用计数器，每当对象被引用一次就加1，引用失效时就减1。当为0的时候就判断对象不会再被引用。
2.可达性分析算法 它的基本思路是通过一个称为“GC Roots”的对象（局部变量）为起始点，搜索所经过的路径称为引用链，当一个对象到GC Roots没有任何引用跟它连接则证明对象是不可用的。(解决了循环利用)
Minor GC、Major GC、Full GC
在年轻代Young space(包括Eden区和Survivor区)中的垃圾回收称之为 Minor GC,Minor GC只会清理年轻代. Major GC清理老年代，但是通常也可以指和Full GC是等价，因为收集老年代的时候往往也会伴随着升级年轻代，收集整个Java堆。 Full GC是对新生代、老年代、永久代统一的回收。 
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/jvm%E5%86%85%E5%AD%98/">Jvm内存</a>
    </h2>
    
  <h5>July 27, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>内存区域#程序计数器
每个线程都有一个独立的程序计数器，指向当前执行的行号。正在执行Java方法的话，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)。如果是Natice方法，则为空。
Java 虚拟机栈
每个方法在执行的时候也会创建一个栈帧，存储了局部变量，操作数，动态链接，方法返回地址。
每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。 局部变量所需内存在编译期间完成分配。 如果线程请求的栈深度大于虚拟机所允许的深度，则StackOverflowError。 如果虚拟机栈可以动态扩展，扩展到无法申请足够的内存，则OutOfMemoryError。 本地方法栈
和虚拟机栈类似，主要为虚拟机使用到的Native方法服务。
也会抛出StackOverflowError 和 OutOfMemoryError。 Java堆
被所有线程共享的一块内存区域，在虚拟机启动的时候创建，用于存放对象实例。
对可以按照可扩展来实现（通过-Xmx 和-Xms 来控制） 当堆中没有内存可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。 方法区
被所有方法线程共享的一块内存区域。
用于存储已经被虚拟机加载的类信息，常量，静态变量等。 这个区域的内存回收目标主要针对常量池的回收和堆类型的卸载。 老版本方法区也被称为永久代，jdk8真正开始废弃永久代，而使用元空间(Metaspace)。 内存模型JMM#定义 JMM定义了线程和主内存之间的抽象关系。 线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程读/写共享变量的副本。
JMM内存模型三大特性
原子性：
AtomicInteger类类。 使用 synchronized 互斥锁来保证操作的原子性。 可见性：
synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。 volatile，会强制将该变量自己和当时其他变量的状态都刷出缓存。 final，被 final 关键字修饰的字段在构造器中一旦初始化完成。 有序性：
源代码 -&gt; 编译器优化的重排 -&gt; 指令并行的重排 -&gt; 内存系统的重排 -&gt;最终执行的命令。 重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 操作指令
指令 名称 描述 lock 加锁 作用于主内存的变量 unlock 解锁 作用于主内存的变量 read 读取 读取主内存的变量 load 加载 将读取的主内存变量加载到工作副本中 use 使用 把工作内存中的变量传递给执行引擎 assign 赋值 将执行引擎接收到的值赋值给工作内存变量 store 存储 作用于工作内存，将工作内存变量传递到主内存 write 写入 作用于主内存，将从工作副本store的值写入主内存中 
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/">递归与回溯问题</a>
    </h2>
    
  <h5>July 24, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>汉诺塔问题#解题思路
1、假设有n个盘子需要移动 2、首先将最上面的n-1个盘子从A借助C移到B柱子 3、然后将最下面的一个盘子从A移到C柱子 4、最后将B当作A，A当作B，将n-1个盘子从B借助C移动到A柱子，再将B柱子最后一个移动到C上（实际重复了2-3步骤，只是把A、B参考对象对换） 5、当只剩下最后一个时，从A移动到C就可以了
Java代码
public class Hanota { public static void main(String[] args) { List&lt;Integer&gt; a = new ArrayList&lt;&gt;(); List&lt;Integer&gt; b = new ArrayList&lt;&gt;(); List&lt;Integer&gt; c = new ArrayList&lt;&gt;(); a.add(2); a.add(1); a.add(0); new Hanota().hanota(a,b,c); System.out.println(c); } public void hanota(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C) { move(A.size(), A, B, C); } public void move(int n, List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C){ if(n == 1){ C.add(A.get(A.size() - 1)); A.
        <a href="/posts/history/%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
    </h2>
    
  <h5>July 23, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>基本组件#注册中心#Spring Cloud Eureka
服务调用#Spring Cloud Ribbon Spring Cloud Feign
服务熔断#Spring Cloud Hystrix
配置中心#Spring Cloud Config
服务总线#Spring Cloud Bus
服务网关#Spring Cloud Zuul
分布式锁#分布式事务#分布式缓存#分布式Session#待继&hellip;&hellip;
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/%E6%A1%B6%E6%8E%92%E5%BA%8F/">桶排序</a>
    </h2>
    
  <h5>July 21, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>计数排序#解题思路 1、取出数组中的最大值。 2、以（最大值 +1）作为辅助数组大小进行记录数组信息。 3、重新把辅助数组中的数据转回数组中。
Java代码
public void countSort(int[] arr) { // 设置最大值变量并找出 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) { if (max &lt; arr[i]) { max = arr[i]; } } // 设置辅助数组 int[] tmp = new int[max+1]; // 将数据保存到辅助数组中 for (int i = 0; i &lt; arr.length; i++) { tmp[arr[i]]++; } // 从辅助数组中数据转到数组中 int index = 0; for (int i = 0; i &lt; tmp.
        <a href="/posts/history/%E6%A1%B6%E6%8E%92%E5%BA%8F/">...</a>
      
    </p>
  </article>
  

  
    <ul class="pagination pagination-default">
      <li class="page-item">
        <a href="/posts/" aria-label="First" class="page-link" role="button"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/6/" aria-label="Previous" class="page-link" role="button"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/5/" aria-label="Page 5" class="page-link" role="button">5</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/6/" aria-label="Page 6" class="page-link" role="button">6</a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 7" class="page-link" role="button">7</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/8/" aria-label="Page 8" class="page-link" role="button">8</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/9/" aria-label="Page 9" class="page-link" role="button">9</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/8/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/9/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">




  <div>
    <a class="flex align-center" href="https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/posts/_index.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  <nav>
  <ul>
  
    
    <li class="book-section-flat">
      <strong>Categories</strong>
      <ul>
      
      </ul>
    </li>
    
  
    
    <li class="book-section-flat">
      <strong>Tags</strong>
      <ul>
      
        <li class="flex justify-between">
          <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
          <span>76</span>
        </li>
      
      </ul>
    </li>
    
  
  </ul>
</nav>

 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












