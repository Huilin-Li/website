<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="我的博客" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/posts/" />

<title>我的博客 | Huilin Li</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/logo.png" >
<link rel="canonical" href="http://localhost:1313/posts/">
<link rel="stylesheet" href="/book.min.f3de075a26891530cb4ae6aeb9b647bcc541281bbd3ec57e8bf60cb157bc209f.css" integrity="sha256-894HWiaJFTDLSuauubZHvMVBKBu9PsV&#43;i/YMsVe8IJ8=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.63b6564d7b3b31dd72b69135cc6c6b73c5ad27a2c8e9373f7ae6f091b7281354.js" integrity="sha256-Y7ZWTXs7Md1ytpE1zGxrc8WtJ6LI6Tc/eubwkbcoE1Q=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/posts/index.xml" title="Huilin Li" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" /><span>Huilin Li</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/me/" class="">Keep Things Simple</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Blog</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/bioworld/" class="">Biology World</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/bioworld/binderdesign/" class="">TP Binder Design</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/bioworld/proteinstruture/" class="">4 levels of protein structure</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/hugo/" class="">Hugo</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/hugo/hugobookgithubaction/" class="">HugoBook&#43;GithubAction</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/hugo/hugo/" class="">Hugo Commands</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/shell/" class="">Bash Scripts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <span>literature</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Plotly</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/blogs/plotly/examples/" class="">Visualization via plotly</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/travel/" class="">World</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href="/posts/"  >
        我的博客
      </a>
  </li>
  
  <li>
    <a href="https://github.com/Huilin-Li"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://www.goodreads.com/review/list/177314441"  target="_blank" rel="noopener">
        goodreads
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>我的博客</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  <nav>
  <ul>
  
    
    <li class="book-section-flat">
      <strong>Categories</strong>
      <ul>
      
      </ul>
    </li>
    
  
    
    <li class="book-section-flat">
      <strong>Tags</strong>
      <ul>
      
        <li class="flex justify-between">
          <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
          <span>76</span>
        </li>
      
      </ul>
    </li>
    
  
  </ul>
</nav>


  </aside>
  
 
      </header>

      
      
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/callable%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%BA%90%E7%A0%81/">Callable返回值的源码</a>
    </h2>
    
  <h5>July 20, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>分析一下Callable是如何拿到返回值的
callable 是如何保存返回值#1、先写一个callable测试类
public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService pool = Executors.newCachedThreadPool(); Future&lt;String&gt; result = pool.submit(() -&gt; { return &#34;Callable Test&#34;; }); System.out.println(result.get()); } 2、看一下submit方法有什么
public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) { if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask; } 构建一个 RunnableFuture 对象，通过AbstractExecutorService的execute方法来执行，那么返回值的获取操作应该就在RunnableFuture对象里了，执行的方法是run()。
3、再深入查看newTaskFor(task)方法
protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) { return new FutureTask&lt;T&gt;(callable); } 发现他实际是构建了一个 FutureTask(callable) 对象，把我们创建的callable对象传进去。
4、那我们来看一下这个对象的run()方法
        <a href="/posts/history/callable%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%BA%90%E7%A0%81/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/">My Sql存储过程</a>
    </h2>
    
  <h5>July 18, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数来调用执行。
创建存储过程基本格式#CREATE [DEFINER = { user | CURRENT_USER }] PROCEDURE sp_name ([proc_parameter[,...]]) [characteristic ...] routine_body proc_parameter: [ IN | OUT | INOUT ] param_name type characteristic: COMMENT &#39;string&#39; | LANGUAGE SQL | [NOT] DETERMINISTIC | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } | SQL SECURITY { DEFINER | INVOKER } routine_body: Valid SQL routine statement [begin_label:] BEGIN [statement_list] …… END [end_label] 使用user表来做测试#CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `age` int(5) DEFAULT NULL, `tag` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 创建一个基本的存储过程#create PROCEDURE select_user(IN user_id INTEGER) BEGIN select * from user where id = user_id; --分号不可少 END; --分号不可少 select_user是创建一个名称为select_user的存储过程。 IN user_id INTEGER是设置一个user_id的参数，类型为整数。 过程体格式：以BEGIN开始，END结束，可嵌套创建。 为了避免存储过程中分号(&quot;;&quot;)结束语句，我们使用分隔符告诉mysql解释器,该段命令是否已经结束了。
        <a href="/posts/history/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%B9%B6%E9%80%89%E6%8B%A9%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%B9%B3%E5%9D%87%E5%80%BC%E7%AD%89%E4%BF%A1%E6%81%AF/">分组查询并选择最大最小平均值等信息</a>
    </h2>
    
  <h5>July 18, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>创建一个用户表，用于测试
CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `age` int(5) DEFAULT NULL, `tag` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) 1、查询tag标签中的最大年龄用户的信息
先排序再查询
select * from (select * from user order by age desc) as u group by tag 先排好序，然后再分组查询组中的第一条，也就是tag中age最大值的那条信息。
也可以这样写
select * from user group by tag order by age desc 如果是查询最小值就order by asc就可以了
2、查询tag标签中平均值最小的tag标签信息
select tag,avg(age) from user group by tag order by avg(age) limit 1 END!
        <a href="/posts/history/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%B9%B6%E9%80%89%E6%8B%A9%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%B9%B3%E5%9D%87%E5%80%BC%E7%AD%89%E4%BF%A1%E6%81%AF/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/restfulapi%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/">Restful Api设计规范</a>
    </h2>
    
  <h5>July 17, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>请求格式
RESTful的核心思想就是，客户端发出的数据+操作指令都是“动词+宾语”的结构，比如GET /articles这个命令，GET是动词，/articles是宾语，有五种HTTP请求方式。
# GET：读取（Read） # POST：新建（Create） # PUT：更新（Update） # PATCH：更新（Update），通常是部分更新 # DELETE：删除（Delete） 动词的覆盖
有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。
POST /api/person/4 HTTP/1.1 X-HTTP-Method-Override: PUT 复数 URL
为了统一起见，建议都使用复数 URL，比如GET /articles/2要好于GET /article/2。
单词问题 出现单词拼接时，用-分隔。
避免多级 URL
常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。
# GET /authors/12/categories/2 这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。 更好的做法是，除了第一级，其他级别都用查询字符串表达。
# GET /authors/12?categories=2 下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。
# GET /articles/published 查询字符串的写法明显更好
# GET /articles?published=true 不要返回纯本文
API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。
客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。下面是一个例子。
GET /orders/2 HTTP/1.1 Accept: application/json 发生错误时，不要返回 200 状态码
        <a href="/posts/history/restfulapi%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/%E5%A0%86%E6%8E%92%E5%BA%8F/">堆排序</a>
    </h2>
    
  <h5>July 16, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>堆定义 每个堆都是完全二叉树（从上到下，从左到右，高最大相差一）。 大顶堆：每个结点的值都大于或等于其左右孩子结点的值。 小顶堆：每个结点的值都小于或等于其左右孩子结点的值。
同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子。 整体解题思路： 1、先把要排序的数据放到数组中。 2、对数组中的数组进行构建成堆。 3、将构建好的堆中的头数据与结尾数据交换并截取出结尾数据。 4、继续将剩下的数据构建成堆，并重复3操作，直到结束。
构建成堆时的几个关键点： 1、尾部元素的父结点计算： (arr.length-1)/2 2、父元素的左结点计算：i * 2 + 1 3、父元素的右结点计算：i * 2 + 2 4、从右到左，从下到上进行比较与交换，最后形成堆
Java代码
public class HeapSort { public static void main(String[] args) { int[] arr = {16, 2,123,7, 3, 20, 17, 8,123,1,221}; HeapSort heapSort = new HeapSort(); heapSort.heapSort(arr); System.out.println(Arrays.toString(arr)); } public void heapSort(int[] arr) { // 找出大头堆，与结尾交换，并截取出尾部 for (int i = arr.length-1; i &gt; 0; i--) { // 将交换后的数组，再次构建成堆 buildHeap(arr,i); swap(arr,0, i); } } /** * 构建堆 * 10 * / \ * 5 8 * / \ / \ * 3 4 6 7 * 正好可以用一个数组表示 {10,5,8,3,4,6,7} * 元素父节点： (i-1)/2 * 元素左子节点： 2i+1 * 元素右子节点： 2i+2 * @param arr 数组 * @param length 堆长度 */ private void buildHeap(int[] arr, int length) { // 父节点 int parent = (length - 1) / 2; for (int i = parent; i &gt;= 0 ; i--) { adjustHeap(arr, i, length); } } /** * 调整堆，，找出最大值节点，与parent节点交换 * @param arr 数组 * @param parent 父节点 * @param length 堆长度 */ private void adjustHeap(int[] arr, int parent, int length) { int leftChild = 2 * parent + 1; int max = parent; // 左节点 if (leftChild &lt;= length &amp;&amp; arr[leftChild] &gt; arr[max]) { max = leftChild; } // 右节点 if (leftChild + 1 &lt;= length &amp;&amp; arr[leftChild + 1] &gt; arr[max]) { max = leftChild + 1; } if (max !
        <a href="/posts/history/%E5%A0%86%E6%8E%92%E5%BA%8F/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">拓扑排序</a>
    </h2>
    
  <h5>July 15, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>基本思想 拓扑排序应用的场合不再是一个简单的数组，而是研究图论里面顶点和顶点连线之间的性质。拓扑排序就是要将这些顶点按照相连的性质进行排序。拓扑排序一般用来理清具有依赖关系的任务。
实现
将问题用一个有向无环图（DAG, Directed Acyclic Graph）进行抽象表达，定义出哪些是图的顶点，顶点之间如何互相关联。 可以利用广度优先搜索或深度优先搜索来进行拓扑排序。 Leetcode题目
Leetcode 207. 课程表 Leetcode 210. 课程表 II 课程表 II 解题
题目
现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例: 输入: 4, [[1,0],[2,0],[3,1],[3,2]] 输出: [0,1,2,3] or [0,2,1,3] 解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 步骤
1、设定顶点（节点）变量个数，和个数之间的路线关系（用二维数组保存） 2、使用一个一维数组用来记录顶点（节点）入度的数量 3、设置一个队列，把入度为0的数放入队列 4、设置一个一维数组用于保存返回值，取出队列元素放到一维数组，并修改其他节点的入度数量。 5、返回
Java代码
public int[] topologicalSort(int numCourses, int[][] prerequisites) { // 用于保存节点入度 int[] in = new int[numCourses]; // 响应结果 int[] res = new int[numCourses]; // 队列，用于保存入度为0的结点 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // 统计节点的入度 for (int[] edge: prerequisites) { in[edge[0]]++; } // 把入度为0的结点放入队列 for (int i = 0; i &lt; numCourses; i++) { if (in[i] == 0) { queue.
        <a href="/posts/history/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序</a>
    </h2>
    
  <h5>July 15, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>基本思想 核心是分治，就是把一个复杂的问题分成两个或多个相同或相似的子问题，然后把子问题分成更小的子问题，直到子问题可以简单的直接求解。
实现 把数组从中间划分成两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素，才开始合并排序。
分解左右并排序 左右两部分合并排序 Java代码
public void mergeSort(int[] nums, int left, int right) { if (left &gt;= right) { return; } int middle = (left + right)/2; // 分化数组 mergeSort(nums, left, middle); // 分化数组 mergeSort(nums, middle+1, right); // 合并左右边 merge(nums,left,middle,right); } // 合并排序好的左边和右边 public void merge(int[] nums, int left, int middle, int right) { //临时数组 int[] tmp = new int[right-left+1]; // start1 左边索引 start2右边索引 index 临时数组索引 int start1 = left, start2 = middle + 1, index = 0; while (start1 &lt;= middle || start2 &lt;= right) { if (start1 &gt; middle) { // 左边已经排序完，只排序右边 tmp[index++] = nums[start2++]; } else if (start2 &gt; right) { //右边已经排序完，只排序左边 tmp[index++] = nums[start1++]; } else if (nums[start1] &gt; nums[start2]) { //两边都没有排序完 tmp[index++] = nums[start2++]; } else { //两边都没有排序完 tmp[index++] = nums[start1++]; } } // 把排序好的数据重新赋值回原数组中 for (int i = left; i &lt;= right; i++) { nums[i] = tmp[i-left]; } } 空间复杂度
        <a href="/posts/history/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">快速排序</a>
    </h2>
    
  <h5>July 15, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>基本思想 快速排序也采用了分治的思想。
实现 随机把一个数作为基准（一般使用第一个数），把原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。
步骤分解 Java代码
public void quickSort(int[] nums, int left, int right) { if (left &gt;= right) { return; } // 找出基准分割界点 int middle = helper(nums, left, right); // 左边继续排序 quickSort(nums,left, middle-1); // 右边继续排序 quickSort(nums, middle+1,right); } private int helper(int[] nums, int left, int right) { // 以val为基准，把比val大的数放一边，比val小的数放一边 int val = nums[left]; while (left &lt; right) { while (val &lt;= nums[right] &amp;&amp; left &lt; right) { right--; } nums[left] = nums[right]; while (val &gt;= nums[left] &amp;&amp; left &lt; right) { left++; } nums[right] = nums[left]; } nums[left] = val; return left; } 时间复杂度
        <a href="/posts/history/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">插入排序</a>
    </h2>
    
  <h5>July 15, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>在冒泡排序中，经过每一轮的排序处理后，数组后端的数是排好序的；而对于插入排序来说，经过每一轮的排序处理后，数组前端的数都是排好序的。
基本思路：当迭代到i时，会向前比较，插入到合适的位置（去在线算法演示体会）。
Java代码
public void insertionSort(int[] nums) { for (int i = 1; i &lt; nums.length; i++) { for (int j = i; j &gt;= 1; j--) { if (nums[j-1] &lt; nums[j]) { break; } int tmp = nums[j-1]; nums[j-1] = nums[j]; nums[j] = tmp; } } } 空间复杂度
假设数组的元素个数是 n，由于在整个排序的过程中，是直接在给定的数组里面进行元素的两两交换，空间复杂度是 O(1)。
时间复杂度
给定的数组按照顺序已经排好 只需要进行 n-1 次的比较，两两交换次数为 0，时间复杂度是 O(n)。这是最好的情况。
给定的数组按照逆序排列 在这种情况下，我们需要进行 n(n-1)/2 次比较，时间复杂度是 O(n2)。这是最坏的情况。
给定的数组杂乱无章 在这种情况下，平均时间复杂度是 O(n2)。
由此可见，和冒泡排序一样，插入排序的时间复杂度是 O(n2)，并且它也是一种稳定的排序算法。
练习题目：LeetCode 第 147 题
        <a href="/posts/history/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">...</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/history/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">冒泡排序</a>
    </h2>
    
  <h5>July 15, 2020</h5>



  

  
  <div>
    
      <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
  </div>
  




    <p>冒泡排序是非常简单的一种排序，我们只需求知道他是怎样交换的就可以了。
基本规则：从左到右依次比较，把最大的数放到右边，依次迭代（先是保证末端排好，再向前迭代）。可以找个“在线算法演示”进行体会。
Java代码
public void bubbleSort(int[] nums) { for (int i = 0; i &lt; nums.length-1; i++) { for (int j = i; j &lt; nums.length-1; j++) { if(nums[j] &gt; nums[j+1]) { int tmp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = tmp; } } } } 那还有没有得优化的呢？结果是当然的。当冒泡还没有完成时，已经排好序了。这时，如果还继续冒泡会浪费时间。在这里，我们可以设置一个flag进行状态的记录。
public void bubbleSort2(int[] nums) { for (int i = 0; i &lt; nums.length-1; i++) { boolean flag = true; for (int j = i; j &lt; nums.
        <a href="/posts/history/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">...</a>
      
    </p>
  </article>
  

  
    <ul class="pagination pagination-default">
      <li class="page-item">
        <a href="/posts/" aria-label="First" class="page-link" role="button"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/7/" aria-label="Previous" class="page-link" role="button"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/5/" aria-label="Page 5" class="page-link" role="button">5</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/6/" aria-label="Page 6" class="page-link" role="button">6</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/7/" aria-label="Page 7" class="page-link" role="button">7</a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 8" class="page-link" role="button">8</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/9/" aria-label="Page 9" class="page-link" role="button">9</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/9/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/9/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">




  <div>
    <a class="flex align-center" href="https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/posts/_index.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>


</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  <nav>
  <ul>
  
    
    <li class="book-section-flat">
      <strong>Categories</strong>
      <ul>
      
      </ul>
    </li>
    
  
    
    <li class="book-section-flat">
      <strong>Tags</strong>
      <ul>
      
        <li class="flex justify-between">
          <a href="/tags/2023-05-07%E4%BB%8Ehalo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/">2023-05-07从halo博客迁移</a>
          <span>76</span>
        </li>
      
      </ul>
    </li>
    
  
  </ul>
</nav>

 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












